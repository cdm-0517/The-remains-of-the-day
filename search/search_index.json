{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u957f\u65e5\u5c06\u5c3d","text":""},{"location":"#members","title":"Members","text":"Name ID Grade Profession \u50a8\u5fb7\u660e CS \u59dc\u6893\u6052 \u6731\u6cfd\u51ef hehepig 2020"},{"location":"#onsite","title":"onsite","text":"<p>Comment:</p> <ul> <li>O for passing during the contest</li> <li>\u00d8 for passing after the contest</li> <li>! for attempted but failed</li> <li>\u00b7 for having not attempted yet</li> </ul> \u00a0\u00a0\u00a0Name\u00a0\u00a0 Date Award Rank Solved A B C D E F G H I J K L M N 2022 ICPC Hefei Onsite 2023-11-20 Au 23/498 8 O O O O O O O O 2022 ICPC Hangzhou Onsite 2023-12-4 Ag 83/640 6 O O O O O O 2022 ICPC EC Final 2023-3-25 Au 24/314 8 O O O O O O O O"},{"location":"#training","title":"Training","text":"Name Date Rank Solved A B C D E F G H I J K L M N O P Q R S"},{"location":"Library/geometry/","title":"Geometry","text":""},{"location":"Library/geometry/#_1","title":"\u5e73\u9762\u6700\u8fd1\u70b9\u5bf9","text":"<pre><code>using ll = long long;\n\nll norm(ll x){\n    return x*x;\n}\n\nstruct point{\n    ll x, y;\n    bool operator &lt; (const point &amp;t) const{\n        return x==t.x?y&lt;t.y:x&lt;t.x;\n    }\n};\n\nvoid solve(){\n    int n; cin &gt;&gt; n;\n    vector&lt;point&gt;vec(n);\n    for(auto &amp;[x, y]: vec) cin &gt;&gt; x &gt;&gt; y;\n    sort(begin(vec), end(vec));\n\n    ll min_d2 = 1e18, min_d = 1e9;\n\n    queue&lt;point&gt;q;\n    set&lt;pair&lt;ll, ll&gt;&gt;now;\n\n    for(auto &amp;[x, y]: vec){\n        while(!q.empty() and x - q.front().x &gt; min_d){\n            auto [lx, ly] = q.front(); q.pop();\n            now.erase({ly, lx});\n        }\n\n        auto lit = now.lower_bound({y-min_d-1, 0});\n        auto rit = now.lower_bound({y+min_d+1, 0});\n\n        for(auto it = lit ; it != rit ; it++) {\n            auto [ty, tx] = *it;\n\n            ll tmp_d2 = norm(x-tx) + norm(y-ty);\n            if(tmp_d2 &lt; min_d2){\n                min_d2 = tmp_d2;\n                min_d = sqrt(tmp_d2 + 1);\n            }\n        }\n\n        q.push({x, y});\n        now.insert({y, x});\n    }\n    cout &lt;&lt; min_d2 &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"Library/geometry/#_2","title":"\u6700\u5c0f\u5706\u8986\u76d6","text":"<pre><code>using db = long double;\nconstexpr db eps = 1e-10;\n\ndb norm(db x){\n    return x * x;\n}\n\nstruct point{\n    db x, y;\n    friend db dis2(const point &amp;A, const point &amp;B){\n        return norm(A.x-B.x) + norm(A.y-B.y);\n    }\n    point operator + (const point &amp;a) const{\n        return {x+a.x, y+a.y};\n    }\n    point operator - (const point &amp;a) const{\n        return {x-a.x, y-a.y};\n    }\n    db operator ^ (const point &amp;a) const{\n        return x*a.y - y*a.x;\n    }\n    point operator * (const db &amp;k) const{\n        return {k*x, k*y};\n    }\n    point rot90() const{\n        return {-y, x};\n    }\n};\n\nstruct line {\n    point p, v;\n\n    point inter(const line &amp;a){\n        return p + v*((a.v^(p-a.p))/(v^a.v));\n    }\n};\n\nstruct circle{\n    point o;\n    db r;\n\n    circle(const point &amp;O, const db &amp;R):o(O), r(R) {}\n\n    circle (const point &amp;a){\n        o = a;\n        r = 0;\n    }\n    circle(const point &amp;a, const point &amp;b){\n        o = (a+b) * 0.5;\n        r = sqrt(dis2(o, a));\n    }\n    circle(const point &amp;a, const point &amp;b, const point &amp;c){\n        auto A = (a+b) * 0.5;\n        auto B = (a+c) * 0.5;\n\n        auto v1 = (a-A).rot90();\n        auto v2 = (c-B).rot90();\n\n        o = line{A, v1}.inter(line{B, v2});\n        r = sqrt(dis2(o, a));\n    }\n    circle (vector&lt;point&gt; vec){\n        mt19937 rng(114514);\n        shuffle(begin(vec), end(vec), rng);\n\n        int n = vec.size();\n\n        *this =circle(vec[0]);\n        for(int i = 1 ; i &lt; n ; i ++){\n            if((*this).is_in(vec[i])==1) continue;\n            *this = circle(vec[i]);\n            for(int j = 0 ; j &lt; i ; j ++){\n                if((*this).is_in(vec[j])==1) continue;\n                *this = circle(vec[i], vec[j]);\n                for(int k = 0 ; k &lt; j ; k ++){\n                    if((*this).is_in(vec[k])==1) continue;\n                    *this = circle(vec[i], vec[j], vec[k]);\n                }\n            }\n        }\n    }\n    // -1 on, 0 out, 1 in\n    int is_in(const point &amp;a) const{\n        db d = sqrt(dis2(o, a));\n        return abs(d-r)&lt;=eps?-1:d&lt;r-eps;\n    }\n};\n</code></pre>"},{"location":"Library/geometry/#_3","title":"\u4e09\u7ef4\u504f\u5e8f","text":"<pre><code>// \u53ef\u80fd\u91cd\u70b9\uff0c\u6c42\u5c0f\u4e8e\u7b49\u4e8e\u7684\u4e09\u7ef4\u504f\u5e8f\nconst int maxn = 2e5 + 100;\n\nstruct fenwick_tree{\n    int val[maxn+100];\n    void add(int x, int add){\n        for(; x&lt;=maxn; x += (x&amp;-x)) val[x] += add;\n    }\n    int ask(int x){\n        int ans = 0;\n        for(;x;x&amp;=x-1) ans += val[x];\n        return ans;\n    }\n    int ask(int l, int r){\n        return ask(r) - ask(l-1);\n    }\n}bit;\n\n\nvoid solve(){\n    int n, k; cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;tuple&lt;int, int, int&gt;&gt;vec(n);\n    for(auto &amp;[a, b, c]: vec) cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    vector&lt;int&gt;ans(n);\n\n    map&lt;tuple&lt;int, int, int&gt;, int&gt;f;\n\n    function&lt;void(int, int, vector&lt;int&gt;)&gt;func = [&amp;](int l, int r, vector&lt;int&gt;indices){\n        if(l==r){\n            stable_sort(begin(indices), end(indices), [&amp;](int x, int y){\n                const auto &amp;[x1, y1, z1] = vec[x];\n                const auto &amp;[x2, y2, z2] = vec[y];\n                return tie(y1, z1)&lt;tie(y2, z2);\n            });\n            for(auto &amp;id: indices){\n                const auto &amp;[x, y, z] = vec[id];\n                ans[id] += bit.ask(z);\n                bit.add(z, 1);\n            }\n            for(auto &amp;id: indices){\n                const auto &amp;[x, y, z] = vec[id];\n                bit.add(z, -1);\n            }\n        }\n        else{\n            int mid = (l+r)/2;\n            vector&lt;int&gt;left_indices, right_indices;\n            for(auto &amp;id: indices) {\n                const auto &amp;[a, b, c] = vec[id];\n                if(a&lt;=mid) left_indices.push_back(id);\n                else right_indices.push_back(id);\n            }\n            func(l, mid, left_indices);\n            func(mid+1, r, right_indices);\n\n            stable_sort(begin(left_indices), end(left_indices), [&amp;](int x, int y){\n                const auto &amp;[x1, y1, z1] = vec[x];\n                const auto &amp;[x2, y2, z2] = vec[y];\n                return tie(y1, z1)&lt;tie(y2, z2);\n            });\n            stable_sort(begin(right_indices), end(right_indices), [&amp;](int x, int y){\n                const auto &amp;[x1, y1, z1] = vec[x];\n                const auto &amp;[x2, y2, z2] = vec[y];\n                return tie(y1, z1)&lt;tie(y2, z2);\n            });\n\n            auto tmp = left_indices;\n            reverse(begin(tmp), end(tmp));\n\n            vector&lt;int&gt;log;\n\n            for(auto &amp;id: right_indices){\n                auto [x1, y1, z1] = vec[id];\n                while(tmp.size() and get&lt;1&gt;(vec[tmp.back()])&lt;=y1){\n                    const auto [x2, y2, z2] = vec[tmp.back()];\n                    bit.add(z2, 1);\n                    log.push_back(tmp.back());\n                    tmp.pop_back();\n                }\n                ans[id] += bit.ask(z1);\n            }\n            for(auto &amp;id: log){\n                auto [x, y, z] = vec[id];\n                bit.add(z, -1);\n            }\n        }   \n    };\n    vector&lt;int&gt;ids(n); iota(begin(ids), end(ids), 0);\n    func(1, k, ids);\n\n    for(int i = 0 ; i &lt; n ; i ++){\n        f[vec[i]] = max(f[vec[i]], ans[i]);\n    }\n    vector&lt;int&gt;freq(n);\n    for(int i = 0 ; i &lt; n ; i ++){\n        freq[f[vec[i]]] ++;\n    }\n    for(int i = 0 ; i &lt; n ; i ++) cout &lt;&lt; freq[i] &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"Library/geometry/#_4","title":"Geometry","text":""}]}